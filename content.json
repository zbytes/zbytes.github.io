{"pages":[{"title":"","text":"zbytes - creativity masterA github organization to shares open-source projects, articles, and notes on the latest cutting-edge technologies of the software industry. Java, Kotlin, Angular, Spring Boot, Spring Cloud, Blockchain, AWS, Microservices, Domain Driven Design, Cloud Native Application, Software Design, Coding Problems document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/about/index.html"}],"posts":[{"title":"OpenAPI Docs Using ReDoc","text":"How to use ReDoc for OpenAPI? In this blog post, I’m going to show you the practical way to use ReDoc for OpenAPI Documentation. In recent times, Rest APIs are de-facto standards for client-server and service-to-service communication. As a business grows, the number of APIs also increases and, after some time it becomes very hard to manage API without using any comprehensive tool and standard. For this reason, the idea of OpenAPI came into the market and, which is a broadly adopted industry standard for describing modern APIs. The process of defining API is very simple in OpenAPI that just required a single file in json or yaml format, but once the number of API increases then real problems starting to appear in the development and maintenance of this single file. A clever person solves a problem. A wise person AVOIDS it. — Albert Einstein ReDoc allows us to document API into multiple file definitions in standard structure and also provide CLI tool @redocly/openapi-cli that can use for validating definition, to generate docs and export OpenAPI definition. Demo &gt; How to do?In this demo, we will see how to use OpenAPI and ReDoc together for documentation. 1. InstallationFirst of all, you must have nodejs installed on your machine. Then install create-openapi-repo globally: 1npm install -g create-openapi-repo 2. Project SetupRun the following command in your preferred folder to create OpenAPI multiple files and folder structure. 1create-openapi-repo Example: 3. Defining APIsFor example, we have to create services for user management and product management then possible APIs are the following: 1234567|_**User Service**_ | _**Product Service**_ ||----------------------------------------------|----------------------------------------------------|| - POST `/users` to create a new user | - POST `/products` to create a new product || - GET `/users` to get all users | - GET `/products` to get all products || - GET `/users/{username}` to get user | - GET `/products/{productId}` to get product || - PUT `/users/{username}` to edit user | - PUT `/products/{productId}` to edit product || - DELETE `/users/{username}` to delete user | - DELETE `/products/{productId}` to delete product | API definitions using multiple files and folders structure with ReDoc: 12345678910111213141516171819202122232425262728openapi/┣ code_samples/┃ ┣ C#/┃ ┃ ┗ echo/┃ ┃ ┗ post.cs┃ ┣ PHP/┃ ┃ ┗ echo/┃ ┃ ┗ post.php┃ ┗ README.md┣ components/┃ ┣ headers/┃ ┃ ┗ PageInfo.yaml┃ ┣ schemas/┃ ┃ ┣ Email.yaml┃ ┃ ┣ Product.yaml┃ ┃ ┗ User.yaml┃ ┣ securitySchemes/┃ ┃ ┣ api_key.yaml┃ ┃ ┣ basic_auth.yaml┃ ┃ ┗ main_auth.yaml┃ ┗ README.md┣ paths/┃ ┣ products.yaml┃ ┣ products@{productId}.yaml┃ ┣ users.yaml┃ ┗ users@{username}.yaml┣ README.md┗ openapi.yaml In the main openapi yaml file we just need to link our separate definitions with API paths. 123456789paths: '/users': $ref: 'paths/users.yaml' '/users/{username}': $ref: 'paths/users@{username}.yaml' '/products': $ref: 'paths/products.yaml' '/products/{productId}': $ref: 'paths/products@{productId}.yaml' Why multiple files and folders? If you don’t use multiple files and folders structure to manage definitions then you will end with the big file like dist.yaml. After looking at it, you might think it is not bad but this is a demo which has only 8 APIs which may not be in a real-world application. You might have 50 or 100 APIs then you will face the real problem of managing single file so that I recommend multiple files and folder structure to manage API definition. Easy to organize. Easy for development. Easy to re-use of objects to avoid duplication. 4. Lint, Build and Generate Docs To Lint 1npm run test To Build 1npm run build To Generate Docs 1npm run start 5. Source Code &gt; Github LinkConclusionIn summary, managing a single OpenAPI definition file is a daunting task instead by using ReDoc we can organize API development in a better way, and also maintenance becomes very easy. Reference https://github.com/Redocly/redoc https://github.com/Redocly/openapi-cli https://github.com/Redocly/create-openapi-repo document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/11/openapi-docs-using-redoc/"},{"title":"Spring Boot App Using Java Code Generated From OpenAPI","text":"How to use OpenAPI to generate code for Spring Boot? You couldn’t find a better place then. I’m going to show you the practical way to generate code and use in spring boot. Over the last three years, my team, and I have been using OpenAPI for API definitions across the microservices. The main benefits of OpenAPI specification: provides a single source for API contracts and easy to render docs by using the same specification. Our team not only benefited from these principle advantages but additionally, we used code generation tools from OpenAPI to generate code for the server application (Spring Boot) as well as for the client application (Angular). Demo &gt; How to do?In this demo, we will see how to build the Spring Boot App using OpenAPI and code generation together. 1. InstallationFirst of all, you must have nodejs and jdk installed on your machine. Then install @openapitools/openapi-generator-cli globally: 1234# install the latest version of \"openapi-generator-cli\"npm install @openapitools/openapi-generator-cli -g# use a specific version of \"openapi-generator-cli\"openapi-generator-cli version-manager set 4.3.1 2. Project SetupBefore writing the code we need to agree on our service API. In this demo, I used the definition that I published in my previous article which specification located in github.com/zbytes. Open the terminal where you want to generate code and run the following command to save the specification. 123wget \\ https://raw.githubusercontent.com/zbytes/openapi-docs-using-redoc/main/dist.yaml \\ -O openapi.yaml I used the following configuration of code generation where you can modify according to your need. The use of each property is described on openapi-generator site. 1234567891011121314151617181920generatorName: 'spring'groupId: 'io.github.bhuwanupadhyay'artifactId: 'spring-boot-using-openapi-code-generation'apiPackage: 'io.github.zbytes.demo.interfaces.rest'modelPackage: 'io.github.zbytes.demo.interfaces.rest.dto'artifactVersion: '1.0.0'library: 'spring-boot'inputSpec: 'openapi.yaml'outputDir: 'demo'additionalProperties: java8: 'true' dateLibrary: 'java8' serializableModel: 'true' serializationLibrary: 'jackson' interfaceOnly: 'true' skipDefaultInterface: 'true' prependFormOrBodyParameters: 'true' useTags: 'true' bigDecimalAsString: 'true' booleanGetterPrefix: 'is' To generate code: 1openapi-generator-cli batch config.yaml The generated minimum structure for java code looks like as below: 1234567rest/┣ dto/┃ ┣ Product.java┃ ┗ User.java┣ ApiUtil.java┣ ProductApi.java┗ UserApi.java 3. API ImplementationThe generated code has skeleton API interfaces on which implementation needs to provide from us. For example, the implementation for Product API Endpoints: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@RestControllerclass WebProductApi implements ProductApi { private final ProductRepository repository; WebProductApi(ProductRepository repository) { this.repository = repository; } @Override public ResponseEntity&lt;Void&gt; createProduct(Product product) { repository.save(toEntity(product)); return ResponseEntity.ok().build(); } @Override public ResponseEntity&lt;Void&gt; deleteProduct(String productId) { return applyVoid(repository, productId, e -&gt; repository.deleteById(e.getProductId())); } @Override public ResponseEntity&lt;Product&gt; getProductById(String productId) { return applyResult(repository, productId, this::toResource); } @Override public ResponseEntity&lt;List&lt;Product&gt;&gt; getProducts(Integer page, Integer size, String sort) { PageRequest request = PageRequest.of(page, size, Sort.by(sort)); Page&lt;ProductEntity&gt; all = repository.findAll(request); List&lt;Product&gt; list = all.stream().map(this::toResource).collect(Collectors.toList()); return ResponseEntity.status(HttpStatus.OK).headers(pageHeaders(all)).body(list); } @Override public ResponseEntity&lt;Void&gt; updateProduct(Product product, String productId) { return applyVoid(repository, productId, e -&gt; { e.with(product.getProductName()); repository.save(e); }); } private Product toResource(ProductEntity entity) { return new Product().productId(entity.getProductId()).productName(entity.getProductName()); } private ProductEntity toEntity(Product product) { ProductEntity entity = new ProductEntity(product.getProductId()); entity.with(product.getProductName()); return entity; } } 4. AdvantagesThere are the following advantages of generated code from the specification. Consistent API contracts. Fail-fast &amp; easy to maintain. Better control of the API interface code. Remove overhead of maintaining POJOs. 5. Source Code &gt; Github LinkConclusionIn summary, the code generation from OpenAPI specification is a very good option to build error-free server code within a short period. I recommend you also give a try and see the results. Reference https://openapi-generator.tech/ https://openapi-generator.tech/docs/generators/spring document.querySelectorAll('.not-gallery-item') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","link":"/2020/11/spring-boot-app-using-java-code-generated-from-openapi/"}],"tags":[{"name":"openapi","slug":"openapi","link":"/tags/openapi/"},{"name":"redoc","slug":"redoc","link":"/tags/redoc/"},{"name":"spring-boot","slug":"spring-boot","link":"/tags/spring-boot/"}],"categories":[{"name":"OpenAPI","slug":"OpenAPI","link":"/categories/OpenAPI/"},{"name":"ReDoc","slug":"OpenAPI/ReDoc","link":"/categories/OpenAPI/ReDoc/"},{"name":"Spring Boot","slug":"OpenAPI/Spring-Boot","link":"/categories/OpenAPI/Spring-Boot/"}]}